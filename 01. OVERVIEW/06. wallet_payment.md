# ðŸ“˜ Use Case: Pay a Bill Using Wallet Balance

## ðŸŽ¯ Goal

Allow a patient to pay an outstanding bill using funds from their wallet account while guaranteeing:

- Wallet balance is sufficient before payment
- Wallet deduction and bill payment occur atomically
- Billing behavior is identical to other payment methods
- No partial or inconsistent state is possible

---

## ðŸ”— Entry Point (URL)


Use Case 2 â€“ Wallet Payment (MOSTLY ALREADY DONE)
ðŸŽ¯ Desired behavior (you stated)

âœ” Cashier selects Wallet Account
âœ” System checks balance
âœ” Payment succeeds only if sufficient
âœ” Wallet balance decreases
âœ” All cascading billing logic runs unchanged

âœ… This already happens â€” because:

Deposit_Receiving.clean() debits wallet

save_model() performs ALL billing logic

Bridge updates, stock updates, lab creation are untouched

ðŸ“Œ This is the correct place for wallet logic
because:

Validation happens before save

It is atomic

Admin + API behave identically

ðŸ”§ What you SHOULD add (small but important)
1. Make wallet logic explicit and safer

Move wallet debit out of clean() into a service:

def debit_wallet(patient_id, amount):
    wallet = Wallet_Account.objects.select_for_update().get(
        patient_id__id=patient_id
    )

    if wallet.account_balance < amount:
        raise ValidationError("Insufficient wallet balance")

    wallet.account_balance -= amount
    wallet.save()


Then in clean():

if self.payment_method == 'Wallet Account':
    debit_wallet(self.patient_id, self.amount_paid)


This prevents race conditions.

2. Ensure DRF uses full_clean()

In your API view that creates payments:

obj = serializer.save()
obj.full_clean()   # VERY IMPORTANT
obj.save()


This guarantees wallet rules run for API exactly like Admin.

4ï¸âƒ£ Final Architecture (How it all fits)
WalletDeposit
   â””â”€â”€ increases Wallet_Account balance

Deposit_Receiving (payment_method = Wallet)
   â”œâ”€â”€ clean() â†’ checks & debits wallet
   â”œâ”€â”€ save_model()
   â”‚    â”œâ”€â”€ mark bridges paid
   â”‚    â”œâ”€â”€ update stock
   â”‚    â”œâ”€â”€ create lab results
   â”‚    â””â”€â”€ audit receipt


âœ” Single source of truth
âœ” No duplicated billing logic
âœ” Admin + API consistent
âœ” Audit-safe

âœ… Summary (Straight Talk)

âœ… Wallet payment already works (model-level)

âŒ Wallet deposit needs its own use case + code

âœ… Your decision to reuse Deposit_Receiving for wallet payments is correct

ðŸ”§ Only small refactors needed for safety and clarity
