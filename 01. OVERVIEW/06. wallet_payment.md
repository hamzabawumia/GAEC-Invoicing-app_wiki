# ğŸ“˜ Use Case: Pay a Bill Using Wallet Balance

## ğŸ¯ Goal

Allow a patient to pay an outstanding bill using funds from their wallet account while guaranteeing:

- Wallet balance is sufficient before payment
- Wallet deduction and bill payment occur atomically
- Billing behavior is identical to other payment methods
- No partial or inconsistent state is possible

---

## ğŸ”— Entry Point (URL)


Wallet Payment API (Pay Bills Using Wallet)

This is where your existing design really shines.

ğŸ¯ Key Insight

Wallet payment is NOT a special payment flow.
It is a normal payment with a different funding source.

So we reuse:

Deposit_Receiving

All existing cascading logic

All existing bridge updates

1ï¸âƒ£ Serializer (Reuse Existing One)

You already have:

class DepositReceivingSerializer(serializers.ModelSerializer):
    ...


We will NOT modify it, except for one thing ğŸ‘‡

2ï¸âƒ£ Critical Fix: Ensure clean() Runs in DRF
âŒ Problem (common DRF bug)

DRF does NOT call model.clean() automatically.

Your wallet logic lives here:

Deposit_Receiving.clean()


So unless we do this manually â†’ wallet checks will be skipped.

3ï¸âƒ£ Correct DRF View for Payments
# invoicing_app/views.py
from django.db import transaction
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from .serializers import DepositReceivingSerializer

@api_view(["POST"])
@transaction.atomic
def create_payment(request):
    serializer = DepositReceivingSerializer(data=request.data)
    serializer.is_valid(raise_exception=True)

    payment = serializer.save(commit=False)

    # ğŸ”’ THIS IS THE KEY LINE
    payment.full_clean()   # triggers wallet debit if payment_method == Wallet Account

    payment.save()
    serializer.save_m2m()

    return Response(
        {"message": "Payment successful"},
        status=status.HTTP_201_CREATED
    )

4ï¸âƒ£ Why This Is Safe

When payment_method == "Wallet Account":

âœ” Deposit_Receiving.clean() runs
âœ” Wallet balance is checked
âœ” Wallet is debited
âœ” If insufficient â†’ ValidationError â†’ transaction rolled back
âœ” If valid â†’ payment proceeds

Then:

Stock updates

Bridge items marked paid

Lab results created

Receipts generated

Exactly the same as cash.

5ï¸âƒ£ API Payload Example (Wallet Payment)
{
  "patient_id": 12,
  "patient_name": "John Doe",
  "hospital_number": "HSP-1023",
  "invoice_id": 88,
  "department": "Laboratory",
  "payment_method": "Wallet Account",
  "amount_paid": 250.00,
  "cash_received": 0
}


cash_received is ignored for wallet internally

ğŸ”’ Invariants Guaranteed

Wallet balance never goes negative

Wallet debit + payment are atomic

Billing logic is untouched

Admin and API behave identically

ğŸ§  Final Architecture Summary
POST /wallet/deposit/
   â†’ Wallet_Account.balance += amount

POST /payments/create/ (payment_method=Wallet)
   â†’ Deposit_Receiving.clean()
       â†’ check wallet balance
       â†’ debit wallet
   â†’ save()
       â†’ mark items paid
       â†’ update stock
       â†’ create lab results

âœ… What Youâ€™ve Achieved

Clean separation of concerns

DRF-safe wallet enforcement

Zero duplication of billing logic

Production-grade financial correctness
