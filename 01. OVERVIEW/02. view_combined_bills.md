# ğŸ“˜ Use Case: View Combined Bills for a Consultation

## ğŸ¯ Goal

Return all billable items across departments for a single consultation in one unified response.

---

## ğŸ”— Entry Point (URL)

```
GET /invoicing_app/combined_bills/?consultation_id=<id>
/invoicing_api/combined_bills/?consultation_id=76
```

**URL configuration:**
- `invoicing_app/urls.py`

```python
url(r'^combined_bills/$', CombinedBillsView.as_view(), name='combined_bills')
```

---

## ğŸ‘¤ User Actions

1. User selects a consultation
2. User requests **Combined Bills**
3. User submits request

---

## âš™ï¸ System Reaction

### Step 1: Frontend / API Client

- Issues HTTP GET request with `consultation_id`

**Code location(s):**
- Frontend / API client
- `invoicing_app/urls.py`

---

### Step 2: Transport Layer

- Django URL resolver matches request
- `consultation_id` is validated

**Code location(s):**
- `invoicing_app/urls.py`

---

### Step 3: Backend Logic

- `CombinedBillsView.get()` executes
- Independently queries the following bridge tables:
  - `Labs_Bridge`
  - `Consultation_Bridge`
  - `Medications_Bridge`
  - `Procedures_Bridge`
  - `Investigations_Bridge`
  - `Billing_Sheet_Bridge`
- Serializes each dataset separately
- Aggregates all results into a single JSON response

**Code location(s):**
- `invoicing_app/views.py`
- `invoicing_app/serializer.py`

---

### Step 4: Persistence

- Read-only access to billing bridge tables
- No database mutation occurs

**Code location(s):**
- `invoicing_app/models.py`

---

## ğŸ”’ Invariants

- Each department is queried independently
- No cross-department coupling
- No state mutation

---

## âŒ What This Use Case Does NOT Do

- Does NOT calculate bill totals
- Does NOT update payment status
- Does NOT create payments

---

## âœ… Final Outcome

- Unified billing snapshot returned for the consultation

